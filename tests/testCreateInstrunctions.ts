// testInstructions.ts
import type { Instruction, MatchPair, Value } from '../src/content-script/util/types'; // Import necessary types
import { createInstructions } from '../src/content-script/util/createInstructions';
import process from 'process';

// --- Helper: Fisher-Yates Shuffle ---
function shuffle<T>(array: T[]): T[] {
  let currentIndex = array.length;
  let randomIndex;
  while (currentIndex !== 0) {
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex--;
    [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
  }
  return array;
}

// --- Helper: Generate Test Data ---
function generateTestData(
  alphabet: string[],
  minSize: number = 5,
  maxSize: number = 15,
): { oldArr: string[]; newArr: string[] } {
  const shuffled = shuffle([...alphabet]);
  const oldSize = Math.floor(Math.random() * (maxSize - minSize + 1)) + minSize;
  const newSize = Math.floor(Math.random() * (maxSize - minSize + 1)) + minSize;

  // Ensure some overlap for potential moves/matches
  const commonSize = Math.min(oldSize, newSize, Math.floor(maxSize * 0.6));
  const commonItems = shuffled.slice(0, commonSize);
  const oldUnique = shuffle(
    shuffled.slice(commonSize).filter((item) => !commonItems.includes(item)),
  );
  const newUnique = shuffle(
    shuffled.slice(commonSize).filter((item) => !commonItems.includes(item)),
  );

  return {
    oldArr: shuffle([...commonItems, ...oldUnique]).slice(0, oldSize),
    newArr: shuffle([...commonItems, ...newUnique]).slice(0, newSize),
  };
}

// --- Helper: Calculate Matches (using Object.is) ---
function calculateMatches(
  oldArr: Value[], // Accept Value[]
  newArr: Value[], // Accept Value[]
): {
  oldMatched: boolean[];
  newMatched: boolean[];
  matchedPairs: MatchPair[];
} {
  const oldLen = oldArr.length;
  const newLen = newArr.length;
  const oldMatched = new Array(oldLen).fill(false);
  const newMatched = new Array(newLen).fill(false);
  const matchedPairs: MatchPair[] = [];

  for (let oldIndex = 0; oldIndex < oldLen; oldIndex++) {
    for (let newIndex = 0; newIndex < newLen; newIndex++) {
      // Use Object.is for matching primitives or identical references
      if (!newMatched[newIndex] && Object.is(oldArr[oldIndex], newArr[newIndex])) {
        oldMatched[oldIndex] = true;
        newMatched[newIndex] = true;
        // Store value for potential debugging, though not strictly needed by createInstructions
        matchedPairs.push({ oldIndex, newIndex, matchType: 'basic', doRecursion: false });
        break; // Found match for oldIndex
      }
    }
  }
  return { oldMatched, newMatched, matchedPairs };
}

// --- Helper: Apply Instructions (for verification) ---
function applyInstructions(oldArr: Value[], instructions: Instruction[]): Value[] {
  let arr = oldArr.slice();
  // Filter out no-op moves before applying
  const effectiveInstructions = instructions.filter(
    (inst) => !(inst.type === 'move' && inst.from === inst.to),
  );

  // Simple application assumes indices are correct relative to the state *before* this specific operation
  // This relies heavily on the correctness of the indices generated by createInstructions
  for (const instruction of effectiveInstructions) {
    try {
      if (instruction.type === 'add') {
        if (instruction.index < 0 || instruction.index > arr.length)
          throw new Error(`Invalid add index: ${instruction.index}`);
        arr.splice(instruction.index, 0, instruction.value);
      } else if (instruction.type === 'remove') {
        if (instruction.index < 0 || instruction.index >= arr.length)
          throw new Error(`Invalid remove index: ${instruction.index}`);
        arr.splice(instruction.index, 1);
      } else if (instruction.type === 'move') {
        if (instruction.from < 0 || instruction.from >= arr.length)
          throw new Error(`Invalid move from index: ${instruction.from}`);
        const [movedItem] = arr.splice(instruction.from, 1);
        if (instruction.to < 0 || instruction.to > arr.length)
          throw new Error(`Invalid move to index: ${instruction.to}`);
        // Adjust 'to' index if it was affected by the splice
        const adjustedTo = instruction.from < instruction.to ? instruction.to - 1 : instruction.to;
        if (adjustedTo < 0 || adjustedTo > arr.length)
          throw new Error(`Invalid adjusted move to index: ${adjustedTo}`);
        arr.splice(adjustedTo, 0, movedItem);
      }
    } catch (e: any) {
      console.error(`Error applying instruction: ${JSON.stringify(instruction)}`, e.message);
      console.error('State before error:', arr);
      throw e; // Re-throw to stop execution on error
    }
  }
  return arr;
}

// --- Helper: Array Equality Check (Deep) ---
// Using a simple JSON stringify for basic deep check, replace with proper deepEquals if needed
function arrayEqual(arr1: Value[], arr2: Value[]): string | null {
  if (arr1.length !== arr2.length) return `Array length different ${arr1.length} vs ${arr2.length}`;
  // Basic deep check
  if (JSON.stringify(arr1) !== JSON.stringify(arr2)) {
    // Find first difference for better debugging (optional)
    for (let i = 0; i < arr1.length; i++) {
      if (JSON.stringify(arr1[i]) !== JSON.stringify(arr2[i])) {
        return `Difference at index ${i}: ${JSON.stringify(arr1[i])} !== ${JSON.stringify(arr2[i])}`;
      }
    }
    return 'Order or content different (JSON check)';
  }
  return null;
}

// --- Test Runner ---
function runSingleTest(testName: string, oldArr: Value[], newArr: Value[]): boolean {
  console.log(`\n--- Running Test: ${testName} ---`);
  console.log('Old Array:', oldArr);
  console.log('New Array:', newArr);

  const { oldMatched, newMatched, matchedPairs } = calculateMatches(oldArr, newArr);
  const instructions = createInstructions(newArr, oldMatched, newMatched, matchedPairs);

  console.log('Generated Instructions:', instructions);

  let resultArr: Value[];
  let error: string | null = null;
  try {
    resultArr = applyInstructions(oldArr, instructions);
    error = arrayEqual(resultArr, newArr);
  } catch (e: any) {
    error = `Error during instruction application: ${e.message}`;
    resultArr = []; // Indicate failure state
  }

  if (error) {
    console.error(`ðŸ”´ FAILED: ${testName}`);
    console.error(`Reason: ${error}`);
    if (resultArr.length > 0) console.log('Result Array:', resultArr);
    return false;
  } else {
    console.log(`ðŸŸ¢ PASSED: ${testName}`);
    return true;
  }
}

// --- Specific Test Cases ---
console.log('=================================');
console.log('=== Running Specific Edge Cases ===');
console.log('=================================');
let specificTestsPassed = true;

specificTestsPassed &&= runSingleTest('Empty to Non-Empty', [], ['A', 'B']);
specificTestsPassed &&= runSingleTest('Non-Empty to Empty', ['A', 'B'], []);
specificTestsPassed &&= runSingleTest('Identical Arrays', ['A', 'B', 'C'], ['A', 'B', 'C']);
specificTestsPassed &&= runSingleTest('Simple Swap', ['A', 'B'], ['B', 'A']);
specificTestsPassed &&= runSingleTest('Insert at Beginning', ['A', 'B'], ['C', 'A', 'B']);
specificTestsPassed &&= runSingleTest('Insert at End', ['A', 'B'], ['A', 'B', 'C']);
specificTestsPassed &&= runSingleTest('Insert in Middle', ['A', 'C'], ['A', 'B', 'C']);
specificTestsPassed &&= runSingleTest('Remove from Beginning', ['A', 'B', 'C'], ['B', 'C']);
specificTestsPassed &&= runSingleTest('Remove from End', ['A', 'B', 'C'], ['A', 'B']);
specificTestsPassed &&= runSingleTest('Remove from Middle', ['A', 'B', 'C'], ['A', 'C']);
specificTestsPassed &&= runSingleTest('Move Across Removed', ['A', 'B', 'C', 'D'], ['A', 'D', 'C']); // B removed, D moved
specificTestsPassed &&= runSingleTest('Move Across Added', ['A', 'B', 'C'], ['A', 'D', 'C', 'B']); // D added, B moved
specificTestsPassed &&= runSingleTest('Full Shuffle', ['A', 'B', 'C', 'D'], ['D', 'A', 'C', 'B']);
specificTestsPassed &&= runSingleTest('Duplicates: Simple Add', ['A', 'A'], ['A', 'A', 'A']);
specificTestsPassed &&= runSingleTest('Duplicates: Simple Remove', ['A', 'A', 'A'], ['A', 'A']);
specificTestsPassed &&= runSingleTest('Duplicates: Move', ['A', 'B', 'A'], ['A', 'A', 'B']);

if (!specificTestsPassed) {
  console.error('\nðŸ”´ Not all specific test cases passed. Aborting random tests.');
  process.exit(1); // Exit with error code
}

// --- Randomized Tests ---
console.log('\n=================================');
console.log('=== Running Randomized Tests ===');
console.log('=================================');

const NUM_RANDOM_RUNS = 10000; // <--- Set the number of runs here
let successes = 0;
let failures = 0;
const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');

for (let i = 0; i < NUM_RANDOM_RUNS; i++) {
  if (i > 0 && i % 100 === 0) {
    console.log(`--- Completed ${i} runs (${successes} passed, ${failures} failed) ---`);
  }
  const { oldArr, newArr } = generateTestData(ALPHABET, 5, 15); // Use smaller ranges for faster tests if needed

  // --- Run the core logic ---
  const { oldMatched, newMatched, matchedPairs } = calculateMatches(oldArr, newArr);
  const instructions = createInstructions(newArr, oldMatched, newMatched, matchedPairs);

  let resultArr: Value[];
  let error: string | null = null;
  try {
    resultArr = applyInstructions(oldArr, instructions);
    error = arrayEqual(resultArr, newArr);
  } catch (e: any) {
    error = `Error during instruction application: ${e.message}`;
    resultArr = []; // Indicate failure state
  }

  // --- Record result ---
  if (error) {
    failures++;
    console.error(`\nðŸ”´ FAILED: Random Run ${i + 1}`);
    console.log('Old Array:', oldArr);
    console.log('New Array:', newArr);
    console.log('Instructions:', instructions);
    if (resultArr.length > 0) console.log('Result Array:', resultArr);
    console.error(`Reason: ${error}`);
    // Optional: break on first failure
    // break;
  } else {
    successes++;
  }
}

// --- Final Report ---
console.log('\n=================================');
console.log('=== Test Summary ===');
console.log(`Total Runs: ${NUM_RANDOM_RUNS}`);
console.log(`ðŸŸ¢ Successes: ${successes}`);
console.log(`ðŸ”´ Failures: ${failures}`);
console.log('=================================');

// Exit with non-zero code if failures occurred
if (failures > 0) {
  process.exit(1);
}
